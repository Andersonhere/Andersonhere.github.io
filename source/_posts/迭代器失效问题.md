---
title: 迭代器失效问题
date: 2021-06-01 21:20:11
tags:
    - stl
    - 迭代器失效
---
# 迭代器失效问题

* 迭代器初步认识
  <font color=#FF0000 >迭代器</font>（iterator）<font color=#FF0000 >是一个</font>可以对其执行类似指针的操作（如：解除引用（operator*()）和递增（operator++()））的<font color=#FF0000 >对象</font>
验证：
```cpp
#include <iostream>
#include <vector>
using namespace std;
int main(){
    vector<int >::iterator item;
    cout<<sizeof(item)<<endl;
    return 0;
}
```
得出的结果为8，指针应为4；所以迭代器并不是指针，不能将指针的操作一成不变的应用在迭代器上


## 顺序类迭代器失效
对于序列式容器，例如vector、deque；由于序列式容器是组合式容器，当当前元素的iterator被删除后，其后的所有元素的迭代器都会失效，这是因为vector，deque都是连续存储的一段空间，所以当对其进行erase操作时，其后的每一个元素都会向前移一个位置。
```c++
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<int> vec={1,2,3,4,5};
    vector<int>::iterator item;
    cout << sizeof(item) << endl;

    for (item = vec.begin(); item != vec.end(); item++)
    {
        if (*item>2){
            cout<<"start: "<<*item<<endl;
            cout<<"size: "<<vec.size()<<endl;
            vec.erase(item);//此处会发生迭代器失效
            cout<<"end: "<<*item<<endl;
            cout<<"size: "<<vec.size()<<endl;
            item--;
        }
    }
    return 0;
}
```
##### 如何防止
* 既然后面的元素都会往前移一个位置，那么我们删除后紧接着将迭代器后退一个位置。或者：删除时不进行自增，遍历时进行自增；
* erase方法可以返回下一个有效的iterator。

```cpp

auto iter = data.erase(std::begin(data)+1); 
/*
Delete the second element
删除一个元素后，vector 的大小减 1；但容量不变。会返回一个迭代器，它指向被删除元素后的一个元素。
这里的返回值和表达式 std::begin(data)+1 相关；如果移除了最后一个元素，会返回 std::end(data)。
*/

for (iter = cont.begin(); iter != cont.end();)
{
    cout<<*item<<endl;
    if (*item>2)
    {
        iter = cont.erase(iter);//erase删除元素，返回下一个迭代器 
    }
    else
    {
        ++iter;
    }
}
```

## 关联类迭代器失效